## 排序
1. 基本的排序算法  
    1.1 冒泡排序  
    1.2 插入排序
2. 常考的排序算法  
    2.1 归并排序  
    2.2 快速排序  
    2.3 拓扑排序
3. 其他排序算法  
    3.1 堆排序  
    3.2 桶排序

### 冒泡排序
**实现**  
每一轮，从无序的数组头部开始，每两个元素比较大小并进行交换，直到这一轮中最大或最小的元素被放置在数组的尾部，然后不断重复这个过程，直到所有元素都拍好位置，核心操作就是元素相互比较  
**算法分析**  
**空间复杂度**  
由于直接在数组里交换元素，空间复杂度为O(1).  
**时间复杂度**  
1. 给定的数组按照顺序已经排好  
这种情况下只需要进行n-1次的比较，两两交换次数为0，时间复杂度是O(n),这是最好的情况
2. 给定的数组按照逆序排列  
在这种情况下，需要进行n(n-1)/2次比较，时间复杂度是O(n²)。这是最坏的情况
3. 给定的数组杂乱无章  
这种情况，平均时间复杂度为O(n²)。  
  
**Python示例代码**
```python
def bubbleSort(nums):
    n = len(nums)
    for i in range(n):
        for j in range(n-i-1):
            if nums[j] > nums[j+1]:
                nums[j],nums[j+1] = nums[j+1],nums[j]
```

由此可见，冒泡排序的时间复杂度是O(n²)。它是一种稳定的排序算法。（稳定是指如果数组里两个相等的数，那么排序前后这两个相等的数的相对位置保持不变。）

### 插入排序
**基本思想**  
不断将尚未排好序的数插入到已经排好序的部分。  
**特点**  
冒泡排序中，经过每一轮的排序处理后，数组后端的数是排好序的；而对插入排序来说，进过每一轮的排序处理后，数组前端的数都是排好序的。  
**算法分析**  
**空间复杂度**  
O(1)  
**时间复杂度**  
1. 给定的数组按照顺序已经排好  
只需要进行n-1次的比较，两两交换次数为0，时间复杂度为O(n),是最好情况  
2. 给定数组按照逆序排列  
需要进行n(n-1)/2次比较，时间复杂度为O(n²),这是最坏情况  
3. 给定数组杂乱无章  
平均时间复杂度为O(n²)。  
  
**Python示例代码**
```python
def insertSort(nums):
    n = len(nums)
    for i in range(1,n):
        insert = nums[i]  # 取出待插入的数
        j = i - 1
        while j >= 0 and nums[j]> insert: # 从后往前寻找插入位置
            nums[j+1] = nums[j]
            j -= 1
        nums[j+1] = insert
```

插入排序复杂度为O(n²)，也是一种稳定的排序算法。LeetCode147题，对一个链表进行插入排序。  

### 归并排序  
**基本思想**  
核心是分治，把一个复杂的问题分解成两个或者多个相同或相似的子问题，然后把子问题分解成更小的子问题，直到子问题可以简单的直接求解，原问题的解就是子问题解的合并。  
**实现**  
一开始把数组从中间划分为两个子数组，一直递归地把子数组划分成更小的子数组，直到子数组中只含有一个元素，才开始排序。  
排序的方法就是按照大小顺序合并两个元素，接着依次按照递归的返回顺序，不断地合并排好序的子数组，直到最后把整个数组的顺序排好。  
**算法分析**  
**空间复杂度**  
由于合并n个元素需要分配一个大小为n的额外数组，合并完成后，这个数组的空间会被释放，所以算法的空间复杂度为O(n)。归并排序也是稳定的排序算法。  
**时间复杂度**  
归并算法是一个不断递归的过程。  
**举例**：数组的元素个数是n，时间复杂度是T(n)的函数。  
**解法**：把这个规模为n的问题分成两个规模分别为n/2的子问题，每个子问题的时间复杂度就是T(n/2)，那么两个子问题的复杂度就是2xT(n/2)。当两个子问题都得到了解决，即两个子数组都排好了序，需要将它们合并，一共有n个元素，每次都需要进行最多n-1次的比较，所以合并的复杂度是O(n)。由此得到递归复杂度公式：T(n)=2 x T(n/2) + O(n)。  

对于公式求解，不断地把一个规模为n的问题分解成规模为n/2的问题，一直分解到规模大小为1。如果n等于2，只需要分一次；如果n等于4，需要分2次。  

以此类推，对于规模为n的问题，一共要进行log(n)层的大小切分。在每一层里，我们都要进行合并，所涉及到的元素其实就是数组里的所有元素，因此，每一层的合并复杂度都是O(n)，所以整体的复杂度就是O(nlogn)。

**Python示例代码**
```python
def mergeSort(nums):
    if not nums:return []
    if len(nums) == 1 : 
        return nums
    else:
        mid = len(nums) // 2
        left = mergeSort(nums[:mid])
        right = mergeSort(nums[mid:])
    return merge(left,right)
    
    
def merge(nums1,nums2):
    result = []
    i,j = 0,0
    while i < len(nums1) and j < len(nums2):
        if nums1[i] < nums2[j]:
            result.append(nums1[i])
            i += 1
        else:
            result.append(nums2[j])
            j += 1
    result = result + nums1[i:] + nums2[j:]
    return result
```

### 快速排序  
**基本思想**  
快速排序也采用了分治的思想。  

**实现**  
把原始的数组筛选成较小和较大的两个子数组（根据基准值），然后递归地排序两个子数组。  
在分成较小和较大的两个子数组过程中，如何选定一个基准值尤为关键。  

**算法分析**  
**时间复杂度**  

1.最优情况：被选出来的基准值都是当前子数组的中间数。  

这样的分割，能保证对于一个规模大小为n的问题，能被均匀分解成两个规模大小为n/2的子问题（归并排序也采用了相同的划分方法），时间复杂度就是：T(n) = 2×T(n/2) + O(n。  

把规模大小为n的问题分解成n/2的两个子问题时，和基准值进行了n-1次比较，复杂度就是O(n)。很显然，在最优情况下，快速排序的复杂度也是O(nlogn)。  

2.最坏情况：基准值选择了子数组里的最大或者最小值  
每次都把子数组分成了两个更小的子数组，其中一个的长度为1，另外一个长度只比原子数组少1。

**空间复杂度**  
和归并排序不同，快速排序在每次递归的过程中，只需要开辟O(1)的存储空间来完成交换操作实现直接对数组的修改，又因为递归次数为logn，所以它的整体空间复杂度完全取决于压堆栈的次数，因此空间复杂度为O(logn)。  

**例题**：LeetCode215，可以使用快速排序来寻找第k大的数。  

**Python示例代码**
```python
def quickSort(nums):
    return qSort(nums,0,len(nums)-1)
    
def qSort(nums,left,right):
    if left < right:  # 确认只含有一个数
        pivot = partition(nums,left,right)
        
        qSort(nums,left,pivot-1)
        qSort(nums,pivot+1,right)
    return nums
    
def partition(nums,left,right):
    pivotkey = nums[left]
    
    while left < right:
        while left < right and nums[right] >= pivotkey:
            right -= 1
        nums[left] = nums[right]
        while left < right and nums[left] <= pivotkey:
            left += 1
        nums[right] = nums[left]
    
    nums[left] = pivotkey
    return left
```

### 拓扑排序  
**基本思想**  
和前面介绍的几种排序不同，拓扑排序应用的场合不再是一个简单的数组，而是研究图论里面顶点和顶点连线之间的性质。拓扑排序就是要将这些顶点按照相连的性质进行排序。  

要能实现拓扑排序，得有几个前提：
1. 图必须是有向图  
2. 图里面没有环

拓扑排序一般用来理清具有依赖关系的任务。  

**举例**：假设有三门课程A、B、C，如果想要学习课程C就必须先把课程B学完，要学习课程B，还得先学习课程A，所以得出课程的学习顺序应该是A->B->C.  
**实现**：  
1. 将问题用一个有向无环图进行抽象表达，定义出哪些是图的顶点，顶点之间如何互相关联。
2. 可以利用广度优先搜索或深度优先搜索来进行拓扑排序。

**算法分析**  
**时间复杂度**  
统计顶点的入度需要O(n)的时间，接下来每个顶点被遍历一次，同样需要O(n)的时间，所以拓扑排序的时间复杂度是O(n)。