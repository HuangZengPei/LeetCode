## 排序
1. 基本的排序算法  
    1.1 冒泡排序  
    1.2 插入排序
2. 常考的排序算法  
    2.1 归并排序  
    2.2 快速排序  
    2.3 拓扑排序
3. 其他排序算法  
    3.1 堆排序  
    3.2 桶排序

### 冒泡排序
**实现**  
每一轮，从无序的数组头部开始，每两个元素比较大小并进行交换，直到这一轮中最大或最小的元素被放置在数组的尾部，然后不断重复这个过程，直到所有元素都拍好位置，核心操作就是元素相互比较  
**算法分析**  
**空间复杂度**  
由于直接在数组里交换元素，空间复杂度为O(1).  
**时间复杂度**  
1. 给定的数组按照顺序已经排好  
这种情况下只需要进行n-1次的比较，两两交换次数为0，时间复杂度是O(n),这是最好的情况
2. 给定的数组按照逆序排列  
在这种情况下，需要进行n(n-1)/2次比较，时间复杂度是O(n²)。这是最坏的情况
3. 给定的数组杂乱无章  
这种情况，平均时间复杂度为O(n²)。  
  
**Python示例代码**
```python
def bubbleSort(nums):
    n = len(nums)
    for i in range(n):
        for j in range(n-i-1):
            if nums[j] > nums[j+1]:
                nums[j],nums[j+1] = nums[j+1],nums[j]
```

由此可见，冒泡排序的时间复杂度是O(n²)。它是一种稳定的排序算法。（稳定是指如果数组里两个相等的数，那么排序前后这两个相等的数的相对位置保持不变。）

### 插入排序
**基本思想**  
不断将尚未排好序的数插入到已经排好序的部分。  
**特点**  
冒泡排序中，经过每一轮的排序处理后，数组后端的数是排好序的；而对插入排序来说，进过每一轮的排序处理后，数组前端的数都是排好序的。  
**算法分析**  
**空间复杂度**  
O(1)  
**时间复杂度**  
1. 给定的数组按照顺序已经排好  
只需要进行n-1次的比较，两两交换次数为0，时间复杂度为O(n),是最好情况  
2. 给定数组按照逆序排列  
需要进行n(n-1)/2次比较，时间复杂度为O(n²),这是最坏情况  
3. 给定数组杂乱无章  
平均时间复杂度为O(n²)。  
  
**Python示例代码**
```python
def insertSort(nums):
    n = len(nums)
    for i in range(1,n):
        insert = nums[i]  # 取出待插入的数
        j = i - 1
        while j >= 0 and nums[j]> insert: # 从后往前寻找插入位置
            nums[j+1] = nums[j]
            j -= 1
        nums[j+1] = insert
```

插入排序复杂度为O(n²)，也是一种稳定的排序算法。LeetCode147题，对一个链表进行插入排序。  

### 归并排序  
**基本思想**  
核心是分治，把一个复杂的问题分解成两个或者多个相同或相似的子问题，然后把子问题分解成更小的子问题，直到子问题可以简单的直接求解，原问题的解就是子问题解的合并。  
**实现**  
一开始把数组从中间划分为两个子数组，一直递归地把子数组划分成更小的子数组，直到子数组中只含有一个元素，才开始排序。  
排序的方法就是按照大小顺序合并两个元素，接着依次按照递归的返回顺序，不断地合并排好序的子数组，直到最后把整个数组的顺序排好。  
**算法分析**  
**空间复杂度**  
由于合并n个元素需要分配一个大小为n的额外数组，合并完成后，这个数组的空间会被释放，所以算法的空间复杂度为O(n)。归并排序也是稳定的排序算法。  
**时间复杂度**  
归并算法是一个不断递归的过程。  
**举例**：数组的元素个数是n，时间复杂度是T(n)的函数。  
**解法**：把这个规模为n的问题分成两个规模分别为n/2的子问题，每个子问题的时间复杂度就是T(n/2)，那么两个子问题的复杂度就是2xT(n/2)。当两个子问题都得到了解决，即两个子数组都排好了序，需要将它们合并，一共有n个元素，每次都需要进行最多n-1次的比较，所以合并的复杂度是O(n)。由此得到递归复杂度公式：T(n)=2 x T(n/2) + O(n)。  

对于公式求解，不断地把一个规模为n的问题分解成规模为n/2的问题，一直分解到规模大小为1。如果n等于2，只需要分一次；如果n等于4，需要分2次。  

以此类推，对于规模为n的问题，一共要进行log(n)层的大小切分。在每一层里，我们都要进行合并，所涉及到的元素其实就是数组里的所有元素，因此，每一层的合并复杂度都是O(n)，所以整体的复杂度就是O(nlogn)。
