## 排序
1. 基本的排序算法  
    1.1 冒泡排序  
    1.2 插入排序
2. 常考的排序算法  
    2.1 归并排序  
    2.2 快速排序  
    2.3 拓扑排序
3. 其他排序算法  
    3.1 堆排序  
    3.2 桶排序

### 冒泡排序
**实现**  
每一轮，从无序的数组头部开始，每两个元素比较大小并进行交换，直到这一轮中最大或最小的元素被放置在数组的尾部，然后不断重复这个过程，直到所有元素都拍好位置，核心操作就是元素相互比较  
**算法分析**  
**空间复杂度**  
由于直接在数组里交换元素，空间复杂度为O(1).  
**时间复杂度**  
1. 给定的数组按照顺序已经排好  
这种情况下只需要进行n-1次的比较，两两交换次数为0，时间复杂度是O(n),这是最好的情况
2. 给定的数组按照逆序排列  
在这种情况下，需要进行n(n-1)/2次比较，时间复杂度是O(n²)。这是最坏的情况
3. 给定的数组杂乱无章  
这种情况，平均时间复杂度为O(n²)。  
  
**Python示例代码**
```python
def bubbleSort(nums):
    n = len(nums)
    for i in range(n):
        for j in range(n-i-1):
            if nums[j] > nums[j+1]:
                nums[j],nums[j+1] = nums[j+1],nums[j]
```

由此可见，冒泡排序的时间复杂度是O(n²)。它是一种稳定的排序算法。（稳定是指如果数组里两个相等的数，那么排序前后这两个相等的数的相对位置保持不变。）

### 插入排序
**基本思想**  
不断将尚未排好序的数插入到已经排好序的部分。  
**特点**  
冒泡排序中，经过每一轮的排序处理后，数组后端的数是排好序的；而对插入排序来说，进过每一轮的排序处理后，数组前端的数都是排好序的。  
**算法分析**  
**空间复杂度**  
O(1)  
**时间复杂度**  
1. 给定的数组按照顺序已经排好  
只需要进行n-1次的比较，两两交换次数为0，时间复杂度为O(n),是最好情况  
2. 给定数组按照逆序排列  
需要进行n(n-1)/2次比较，时间复杂度为O(n²),这是最坏情况  
3. 给定数组杂乱无章  
平均时间复杂度为O(n²)。  
  
**Python示例代码**

插入排序复杂度为O(n²)，也是一种稳定的排序算法。LeetCode147题，对一个链表进行插入排序。  

### 归并排序  
**基本思想**  
核心是分治，把一个复杂的问题分解成两个或者多个相同或相似的子问题，然后把子问题分解成更小的子问题，直到子问题可以简单的直接求解，原问题的解就是子问题解的合并。