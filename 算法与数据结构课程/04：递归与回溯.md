# 递归与回溯 

递归和回溯的关系密不可分：  
- 递归的基本性质就是函数调用，在处理问题的时候，递归往往是把一个大规模的问题不断地变小然后进行推导的过程。
- 回溯则是利用递归的性质，从问题的起始点出发，不断地进行尝试，回头一步甚至多步再做选择，直到最终抵达终点的过程。

### 递归 
#### 算法思想  
递归算法是一种调用自身函数的算法（二叉树的许多性质在定义上就满足递归）。  
将一个问题的规模变小，然后再利用从小规模问题中得出的结果，结合当前的值或者情况，得出最终的结果。  

通俗来说，把要实现的递归函数看成是已经实现好的，直接利用来解决一些子问题，然后需要考虑的就是如何根据子问题的解以及当前面对的情况得出答案。这种算法也被称为自顶向下的算法。  

归纳总结一下递归函数的解题模版。  
#### 解题步骤  
1. 判断当前情况是否非法，如果非法就立即返回，这一步也被称为完整性检查（Sanity Check）。例如，看看当前处理的情况是否越界，是否出现了不满足条件的情况。通常，这一部分代码都是写在最前面的。
2. 判断是否满足结束递归的条件。在这一步当中，处理的基本上都是一些推导过程当中所定义的初始情况。
3. 将问题的规模缩小，递归调用。在归并排序和快速排序中，我们将问题的规模缩小了一半，而在汉诺塔和解码的例子中，我们将问题的规模缩小了一个。
4. 利用在小规模问题中的答案，结合当前的数据进行整合，得出最终的答案。  

**代码模板**
```python
def fn(n):
  # 第一步：判断输入或者状态是否非法
  if input/state is invalid:
    return
  
  # 第二步：判断递归是否应当结束
  if (match condition):
    return some value
  
  # 第三步：缩小问题规模
  result1 = fn(n1)
  result2 = fn(n2)
  ···
  
  # 第四步：整合结果
  return combine(result1,result2)
```

**例题**：LeetCode91、247

#### 算法分析 
分析非递归算法的时间复杂度非常直接，例如，前一节课里分析过冒泡排序以及插入排序的时间复杂度，分析方法就是数有多少层循环，由于每层循环里面执行的操作都是对比和交换，时间复杂度是 O(1)，所以，最终的时间复杂度就是将每层循环的长度相乘。  

分析递归算法推荐两种方法：
- 迭代法
- 公式法  

**迭代法**  
**举例**：分析汉诺塔递归函数的时间复杂度。  
```java
void hano(char A, char B, char C, int n) {
    if (n > 0) {
        hano(A, C, B, n - 1);
        move(A, C);
        hano(B, A, C, n - 1);
    }
}
```
假设这个递归函数的运行时间是 T(n)。
1. if 语句（一般取 if 块或 else 块之间最大的时间复杂度）中，比较和判断 n 的大小，CPU 的执行时间为 1 个单位。
2. 两次调用递归函数，每次都使问题的规模减少 1 个，得到两倍的 T(n-1)。打印输出的语句，CPU 的执行时间也为 1 个单位。因此得出：T(n) = 1 + 2×T(n - 1) + 1。

当 n=0 的时候，T(0) = 1，因为当没有盘子的时候，if 语句也要进行一次比较，判断 n 是否大于 0。
3. 用迭代法将 T(n) 进行展开。  
T(n - 1) = 2×T(n - 2) + 1，以此类推，不断地代入到 T(n) 的表达式当中，得到如下关系：

T(n) = 2× (2×T(n - 2) + 1) + 1 = 2<sup>2</sup>×T(n - 2) + (2 + 1)  
T(n) = 2×(2× (2×T(n - 3) + 1) + 1) + 1 = 2<sup>3</sup>×T(n - 3) + (4 + 2 + 1)  
···  
T(n) = 2<sup>k</sup>×T(n - k) + (2<sup>k</sup>- 1)  

其中，1 + 2 + 4 + 8 + … 是一个等比数列，由求和公式得到 2<sup>k</sup>- 1。当 k 等于 n 的时候，T(n) = 2<sup>n</sup>×T(0) + (2<sup>n</sup>- 1)，由于 T(0) 等于 1，所以最终 T(n) = 2×2<sup>n</sup>- 1。  
对 T(n) 求 O 的值得到：O(n) = O(T(n)) = O(2×2<sup>n</sup>- 1) ，忽略掉常量和系数，O(n) = O(2<sup>n</sup>)。  
所以，整个算法的时间复杂度就是O(2<sup>n</sup>)  
**公式法**  
公式法可以说是计算递归函数复杂度最方便的工具，当递归函数的时间执行函数满足如下的关系式时，我们可以利用公式法：T(n) = a×T(n/b) + f(n)。  

其中，f(n) 是每次递归完毕之后额外的计算执行时间。例如，在归并排序中，每次递归处理完两边的数组后，我们需要执行合并的操作，那么这个操作的执行时间就是 f(n)。  

当参数 a、b 都确定的时候，光看递归的部分，它的时间复杂度就是：O(n^log<sub>b</sub>a).

由于时间复杂度求的是上界（upper bound)，通过对比递归部分的时间复杂度和 f(n) 的大小关系，得出最后的整体时间复杂度。牢记以下三种情况和相应公式：  
1. 当递归部分的执行时间 nlog(b)a 大于 f(n) 的时候，最终的时间复杂度就是 O(n^log<sub>b</sub>a).
2. 当递归部分的执行时间 nlog(b)a 小于 f(n) 的时候，最终的时间复杂度就是 f(n)。
3. 当递归部分的执行时间 nlog(b)a 等于 f(n) 的时候，最终的时间复杂度就是 O(n^log<sub>b</sub>a)logn。

**举例1**：分析归并排序的时间复杂度。  
T(n) = 2T(n/2) + n  
a = 2, b = 2, f(n) = n  
log<sub>b</sub>a = 1, n<sup>1</sup> = n  
符合第三种情况，最终时间复杂度为O(nlogn)

**举例2**：分析下面函数的时间复杂度。  
```java
int recursiveFn(int n) {
    if (n == 0) {
        return 0;
    }
    return recursiveFn(n / 4) + recursiveFn(n / 4);
}
```
得出时间执行函数：T(n) =  2×T(n/4) + 1，a = 2，b = 4，f(n) = 1。  
代入公式得到：n^log<sub>4</sub>2 = n<sup>0.5</sup>，当 n>1 的时候，n<sup>0.5</sup>>1，因此，时间复杂度就是  O(n<sup>0.5</sup>).

### 回溯
#### 算法思想
回溯实际上是一种试探算法，这种算法跟暴力搜索最大的不同在于，在回溯算法里，是一步一步地小心翼翼地进行向前试探，会对每一步探测到的情况进行评估，如果当前的情况已经无法满足要求，那么就没有必要继续进行下去，也就是说，它可以帮助我们避免走很多的弯路。

回溯算法的特点在于，当出现非法的情况时，算法可以回退到之前的情景，可以是返回一步，有时候甚至可以返回多步，然后再去尝试别的路径和办法。这也就意味着，想要采用回溯算法，就必须保证，每次都有多种尝试的可能。

#### 解题模板
**解题步骤**  
1. 判断当前情况是否非法，如果非法就立即返回；
2. 当前情况是否已经满足递归结束条件，如果是就将当前结果保存起来并返回；
3. 当前情况下，遍历所有可能出现的情况并进行下一步的尝试；
4. 递归完毕后，立即回溯，回溯的方法就是取消前一步进行的尝试。
**代码模板**
```java
def fn(n) {

    // 第一步：判断输入或者状态是否非法？
    if (input/state is invalid) {
        return;
  }

    // 第二步：判读递归是否应当结束?
    if (match condition) {
        return some value;
  }

    // 遍历所有可能出现的情况
    for (all possible cases) {
  
        // 第三步: 尝试下一步的可能性
        solution.push(case)
        // 递归
        result = fn(m)

        // 第四步：回溯到上一步
        solution.pop(case)
    
    }
    
}
```
**例题** ：LeetCode39、51