## 递归与回溯  

递归和回溯的关系密不可分：  
- 递归的基本性质就是函数调用，在处理问题的时候，递归往往是把一个大规模的问题不断地变小然后进行推导的过程。
- 回溯则是利用递归的性质，从问题的起始点出发，不断地进行尝试，回头一步甚至多步再做选择，直到最终抵达终点的过程。

**递归**  
**算法思想**  
递归算法是一种调用自身函数的算法（二叉树的许多性质在定义上就满足递归）。  
将一个问题的规模变小，然后再利用从小规模问题中得出的结果，结合当前的值或者情况，得出最终的结果。  

通俗来说，把要实现的递归函数看成是已经实现好的，直接利用来解决一些子问题，然后需要考虑的就是如何根据子问题的解以及当前面对的情况得出答案。这种算法也被称为自顶向下的算法。  

归纳总结一下递归函数的解题模版。  
**解题步骤**  
1. 判断当前情况是否非法，如果非法就立即返回，这一步也被称为完整性检查（Sanity Check）。例如，看看当前处理的情况是否越界，是否出现了不满足条件的情况。通常，这一部分代码都是写在最前面的。
2. 判断是否满足结束递归的条件。在这一步当中，处理的基本上都是一些推导过程当中所定义的初始情况。
3. 将问题的规模缩小，递归调用。在归并排序和快速排序中，我们将问题的规模缩小了一半，而在汉诺塔和解码的例子中，我们将问题的规模缩小了一个。
4. 利用在小规模问题中的答案，结合当前的数据进行整合，得出最终的答案。  

**代码模板**
```python
def fn(n):
  # 第一步：判断输入或者状态是否非法
  if input/state is invalid:
    return
  
  # 第二步：判断递归是否应当结束
  if (match condition):
    return some value
  
  # 第三步：缩小问题规模
  result1 = fn(n1)
  result2 = fn(n2)
  ···
  
  # 第四步：整合结果
  return combine(result1,result2)
```

**例题**：LeetCode91、247

**算法分析**  
分析非递归算法的时间复杂度非常直接，例如，前一节课里分析过冒泡排序以及插入排序的时间复杂度，分析方法就是数有多少层循环，由于每层循环里面执行的操作都是对比和交换，时间复杂度是 O(1)，所以，最终的时间复杂度就是将每层循环的长度相乘。  

分析递归算法推荐两种方法：
- 迭代法
- 公式法  

**迭代法**  
**举例**：分析汉诺塔递归函数的时间复杂度。  
```java
void hano(char A, char B, char C, int n) {
    if (n > 0) {
        hano(A, C, B, n - 1);
        move(A, C);
        hano(B, A, C, n - 1);
    }
}
```
假设这个递归函数的运行时间是 T(n)。
1. if 语句（一般取 if 块或 else 块之间最大的时间复杂度）中，比较和判断 n 的大小，CPU 的执行时间为 1 个单位。
2. 两次调用递归函数，每次都使问题的规模减少 1 个，得到两倍的 T(n-1)。打印输出的语句，CPU 的执行时间也为 1 个单位。因此得出：T(n) = 1 + 2×T(n - 1) + 1。

当 n=0 的时候，T(0) = 1，因为当没有盘子的时候，if 语句也要进行一次比较，判断 n 是否大于 0。
3. 用迭代法将 T(n) 进行展开。
T(n - 1) = 2×T(n - 2) + 1，以此类推，不断地代入到 T(n) 的表达式当中，得到如下关系：

T(n) = 2× (2×T(n - 2) + 1) + 1 = 2<sup>2</sup>×T(n - 2) + (2 + 1)  
T(n) = 2×(2× (2×T(n - 3) + 1) + 1) + 1 = 2<sup>3</sup>×T(n - 3) + (4 + 2 + 1)  
···  
T(n) = 2<sup>k</sup>×T(n - k) + (2<sup>k</sup>- 1)  

其中，1 + 2 + 4 + 8 + … 是一个等比数列，由求和公式得到 2<sup>k</sup>- 1。当 k 等于 n 的时候，T(n) = 2<sup>n</sup>×T(0) + (2<sup>n</sup>- 1)，由于 T(0) 等于 1，所以最终 T(n) = 2×2<sup>n</sup>- 1。  
对 T(n) 求 O 的值得到：O(n) = O(T(n)) = O(2×2<sup>n</sup>- 1) ，忽略掉常量和系数，O(n) = O(2<sup>n</sup>)。  
所以，整个算法的时间复杂度就是O(2<sup>n</sup>)