## 常用数据结构对比

#### 数组
优点
- 构建非常简单，在内存中占连续空间
- 能在O(1)的时间里根据数组的下标查询某个元素

缺点
- 构建时必须分配一段连续的空间
- 查询某个元素是否存在时需要遍历整个数组，耗费O(n)的时间（n为元素个数）
- 删除和添加某个元素时，同样需要耗费O(n)的时间

应用场景

需要快速查询、不需要经常添加和删除元素

例题  Leetcode 242

### 链表
优点
- 能灵活地分配内存空间
- 能在O(1)时间内删除或者添加元素，前提是该元素的前一个元素已知，当然也取决于是单链表还是双链表，在双链表中，如果一直该元素的后一个元素，同样可以在O(1)时间内删除或者添加该元素

缺点
- 不能够快速查询元素，每次都要从链表头开始一个一个读取
- 查询第k个元素需要O(k)时间

应用场景

如果要解决的问题里面需要很多快速查询，链表可能并不合适；如果遇到的问题中，数据的元素个数不确定，而且需要经常进行数据的添加和删除，那么链表会比较合适。而如果数据元素大小确定，删除插入的操作不多，那么数组可能更合适

经典解法
- 利用快慢指针（有时候需要用到三个指针）：典型题目例如：链表的翻转，寻找倒数第k个元素，寻找链表中间位置的元素，判断链表是否有环等等
- 构建一个虚假的链表头：一般用在要返回新的链表的题目中，比如，给定两个排好序的链表，要求将他们整合在一起并排好序，又比如将一个链表中的奇数和偶数按照原定的顺序分开后重新组合成一个新的链表，链表的头一半是奇数，后一半是偶数。

### 栈
特点
- 后进先出（LIFO），可以使用单链表实现。因为只针对栈顶元素进行操作，借用单链表的头就可以让所有栈的操作在O(1)的时间内完成

应用场景
- 在解决某个问题的时候，只要求关心最近一次的操作，并且在操作完成了之后，需要向前查找到更前一次的操作

例题
- 20 括号匹配  739 生成气温列表

### 队列
特点
- 先进先出（FIFO），只允许在队尾添加数据，只允许在对头删除数据。
- 借助双链表实现队列

应用场景
- 需要按照一定的顺序处理数据，同时数据的数据量在不断的变化的时候。例如广度优先搜索常用队列完成

### 双端队列
双端队列允许在队列的头尾两端都能够在O(1)的时间内进行数据的查看、添加和删除。

- 实现：与队列相似，可以利用一个双向链表实现双端队列
- 应用场景：最常用的地方就是实现一个长度动态变化的窗口或者连续区间
- 例题：LeetCode 239

### 树
树的结构十分直观，而树的很多概念定义都有一个相同的特点：递归，也就是说，一棵树要满足某种性质，往往要求每个节点都必须满足。例如，在定义一棵二叉搜索树时，每个节点也都必须是一棵二叉搜索树。正因为树有这样的性质，大部分关于树的面试题都与递归有关。

常考的树的形状有：普通二叉树、平衡二叉树、完全二叉树、二叉搜索树、四叉树、多叉树

主要考察点：树的遍历以及序列化

树的遍历
- 前序遍历：根节点 -> 左子树 -> 右子树 应用场景：在树里进行搜索以及创建一棵新的树。
- 中序遍历：左子树 -> 根节点 -> 右子树 应用场景：最常见的是二叉搜素树，由于二叉搜索树的性质就是左孩子小于根节点，根节点小于右孩子，对二叉搜索树进行中序遍历的时候，被访问到的节点大小是按顺序进行的。
- 后序遍历：左子树  -> 右子树 -> 根节点. 应用场景：在对某个节点进行分析的时候，需要来自左子树和右子树的信息。收集信息的操作是从树的底部不断地往上进行，好比你在修剪一棵树的叶子，修剪的方法是从外面不断地往根部将叶子一片片地修剪掉。
- 掌握好这三种遍历的递归写法和非递归写法是非常重要的，懂得分析各种写法的时间复杂度和空间复杂度同样重要。
- 例题 LeetCode 250,230
