## 二分搜索及贪心算法

二分搜索算法看似简单，写对很难，而且变形很多。所以最容易被拿来在面试中考察大家写 code 的能力。本节课可以总结出解决二分搜索题目的常用套路。


贪婪算法虽然是一种比较直观的算法，但是比较难的地方在于证明它的正确性。换句话说，有时候它会让你误以为得到的答案是正确的解，其实不然。

### 二分搜索（Binary Search）
二分搜索（折半搜索）的 Wikipedia 定义：是一种在有序数组中查找某一特定元素的搜索算法。从定义可知，运用二分搜索的前提是数组必须是排好序的。另外，输入并不一定是数组，也有可能是给定一个区间的起始和终止的位置。  

**优点**：时间复杂度是 O(lgn)，非常高效。因此也称为对数搜索。

**缺点**：要求待查找的数组或者区间是排好序的。

对数组进行动态的删除和插入操作并完成查找，平均复杂度会变为 O(n)。此时应当考虑采取自平衡的二叉查找树：  
- 在 O(nlogn) 的时间内用给定的数据构建出一棵二叉查找树；
- 在 O(logn) 的时间里对目标数据进行搜索；
- 在 O(logn) 的时间里完成删除和插入的操作。

因此，当输入的数组或者区间是排好序的，同时又不会经常变动，而要求从里面找出一个满足条件的元素的时候，二分搜索就是最好的选择。

二分搜索一般化的解题思路如下。  
![bs1](assets/bs1.gif)  
1. 从已经排好序的数组或区间中取出中间位置的元素，判断该元素是否满足要搜索的条件，如果满足，停止搜索，程序结束。
2. 如果正中间的元素不满足条件，则从它两边的区域进行搜索。由于数组是排好序的，可以利用排除法，确定接下来应该从这两个区间中的哪一个去搜索。
3. 通过判断，如果发现真正要找的元素在左半区间的话，就继续在左半区间里进行二分搜索。反之，就在右半区间里进行二分搜索。
**递归解法**  
优点：简洁；缺点：执行消耗大

例题：假设我们要从一个排好序的数组里 {1, 3, 4, 6, 7, 8, 10, 13, 14} 查看一下数字 7 是否在里面，如果在，返回它的下标，否则返回 -1。  
**代码实现**  
```java
递归写法的代码模板如下。

// 二分搜索函数的定义里，除了要指定数组 nums 和目标查找数 target 之外，还要指定查找区间的起点和终点位置，分别用 low 和 high 去表示。
int binarySearch(int[] nums, int target, int low, int high) {
        // 为了避免无限循环，先判断，如果起点位置大于终点位置，表明这是一个非法的区间，已经尝试了所有的搜索区间还是没能找到结果，返回 -1。 

if (low > high) {
        return -1;
    }
    // 取正中间那个数的下标 middle。
    int middle = low + (high - low) / 2;
    
    // 判断一下正中间的那个数是不是要找的目标数 target，是，就返回下标 middle。    
    if (nums[middle] == target) {
        return middle;
    }
    
    // 如果发现目标数在左边，就递归地从左半边进行二分搜索。
    if (target < nums[middle]) {
        return binarySearch(nums, target, low, middle - 1);
      } else {
        return binarySearch(nums, target, middle + 1, high);
    }//否则从右半边递归地进行二分搜索。
}
```
注意：  
1. 在计算 middle 下标的时候，不能简单地用 (low + hight) / 2，可能会导致溢出。
2. 在取左半边以及右半边的区间时，左半边是 [low, middle - 1]，右半边是 [middle + 1, high]，这是两个闭区间。因为已经确定了 middle 那个点不是我们要找的，就没有必要再把它加入到左、右半边了。
3. 对于一个长度为奇数的数组，例如：{1, 2, 3, 4, 5}，按照 low + (high - low) / 2 来计算，middle 就是正中间的那个位置，对于一个长度为偶数的数组，例如 {1, 2, 3, 4}，middle 就是正中间靠左边的一个位置。

**时间复杂度** 
假设我们要对长度为 n 的数组进行二分搜索，T(n) 是执行时间函数，我们可以得到 T(n) = T(n/2)+ 1  
 代入公式法得：a = 1，b = 2，f(n) = 1，因此：O(nlog(b)a) = O(n0) = 1 等于 O(f(n))，时间复杂度就是 O(nlog(b)alogn) = O(logn)。
 
 **非递归解法**  
 **代码实现**  
 ```java
 非递归写法的代码模板如下。

int binarySearch(int[] nums, int target, int low, int high) {
    // 在 while 循环里，判断搜索的区间范围是否有效
    while (low <= high) {
        // 计算正中间的数的下标
        int middle = low + (high - low) / 2;
    
    // 判断正中间的那个数是不是要找的目标数 target。如果是，就返回下标 middle
    if (nums[middle] == target) {
        return middle;
    }
    
    // 如果发现目标数在左边，调整搜索区间的终点为 middle - 1；否则，调整搜索区间的起点为 middle + 1
    if (target < nums[middle]) {
        high = middle - 1;
      } else {
        low = middle + 1;
      }
    }

    // 如果超出了搜索区间，表明无法找到目标数，返回 -1  
    return -1;
}
 ```
 **核心步骤**  
 1. 确定搜索的范围和区间
 2. 取中间的数判断是否满足条件
 3. 如果不满足条件，判定应该往哪个半边继续进行搜索

 二分搜索看起来简单，但是 Programming Pearls 这本书的作者 Jon Bentley 提到，只有 10% 的程序员能正确地写出二分搜索的代码。面试题经常是经典二分搜索的变形，但万变不离其中，需要把握好二分搜索的核心。
 
**例题分析一：找确定的边界**  
边界分上边界和下边界，有时候也被成为右边界和左边界。确定的边界指边界的数值等于要找的目标数。

例题：LeetCode 第 34 题，在一个排好序的数组中找出某个数第一次出现和最后一次出现的下标位置。

示例：输入的数组是：{5, 7, 7, 8, 8, 10}，目标数是 8，那么返回 {3, 4}，其中 3 是 8 第一次出现的下标位置，4 是 8 最后一次出现的下标位置。  
![bs2](assets/bs2.gif)  
**解题思路**  
在二分搜索里，比较难的是判断逻辑，对这道题来说，什么时候知道这个位置是不是 8 第一次以及最后出现的地方呢？

把第一次出现的地方叫下边界（lower bound），把最后一次出现的地方叫上边界（upper bound）。

那么成为 8 的下边界的条件应该有两个。  
1. 该数必须是8；
2. 该数的左边一个数必须不是8；
  - 8的左边有数，那么该数必须小于8
  - 8的左边没有数，即8是数组的第一个数

而成为 8 的上边界的条件也应该有两个。
1. 该数必须是8；
2. 该数的右边一个数必须不是8；
  - 8的右边有数，那么该数必须大于8
  - 8的右边没有数，即8是数组的最后一个数

**代码实现**  
用递归的方法来寻找下边界，代码如下：  
```java
int searchLowerBound(int[] nums, int target, int low, int high) {
    if (low > high) {
        return -1;
    }
  
    int middle = low + (high - low) / 2;
    //判断是否是下边界时，先看看 middle 的数是否为 target，并判断该数是否已为数组的第一个数，或者，它左边的一个数是不是已经比它小，如果都满足，即为下边界。
    if (nums[middle] == target && (middle == 0 || nums[middle - 1] < target)) {
        return middle;
    }

    if (target <= nums[middle]) {
        return searchLowerBound(nums, target, low, middle - 1);
      } else {
        return searchLowerBound(nums, target, middle + 1, high);
      } //不满足，如果这个数等于 target，那么就得往左边继续查找。
}
```
查找上边界的代码如下：  
```java
int searchUpperBound(int[] nums, int target, int low, int high) {
    if (low > high) {
        return -1;
    }
  
    int middle = low + (high - low) / 2;
    
    //判断是否是上边界时，先看看 middle 的数是否为 target，并判断该数是否已为数组的最后一个数，或者，它右边的数是不是比它大，如果都满足，即为上边界。    
    if (nums[middle] == target && (middle == nums.length - 1 || nums[middle + 1] > target)) {
        return middle;
    }
    
    if (target < nums[middle]) {
        return searchUpperBound(nums, target, low, middle - 1);
      } else {
        return searchUpperBound(nums, target, middle + 1, high);
      } //不满足时，需判断搜索方向。
}
```

**例题分析二：找模糊的边界**  
二分搜索可以用来查找一些模糊的边界。模糊的边界指，边界的值并不等于目标的值，而是大于或者小于目标的值。

例题：从数组 {-2, 0, 1, 4, 7, 9, 10} 中找到第一个大于 6 的数。  
**解题思路**  
在一个排好序的数组里，判断一个数是不是第一个大于 6 的数，只要它满足如下的条件：  
1. 该数要大于6
2. 该数有可能是数组里的第一个数，或者它之前的一个数比6小。
只要满足了上面的条件就是第一个大于6的值  
**代码实现**  
```java
Integer firstGreaterThan(int[] nums, int target, int low, int high) {
    if (low > high) {
        return null;
    }
  
    int middle = low + (high - low) / 2;
    
    //判断 middle 指向的数是否为第一个比 target 大的数时，须同时满足两个条件：middle 这个数必须大于 target；middle 要么是第一个数，要么它之前的数小于或者等于 target。 
    if (nums[middle] > target && (middle == 0 || nums[middle - 1] <= target)) {
        return middle;
    }


    if (target < nums[middle]) {
        return firstGreaterThan(nums, target, low, middle - 1);
      } else {
        return firstGreaterThan(nums, target, middle + 1, high);
      }
}
```